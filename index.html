<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç–Ω—ã–π –±–æ—Ç - –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —à–∞—Ö –∏ –º–∞—Ç</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: white;
            text-align: center;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(30, 30, 40, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        h1 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 2.2em;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            background: linear-gradient(90deg, #f8f8f8, #b0b0b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .board-container {
            position: relative;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.1);
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 500px;
            height: 500px;
            border: 3px solid #5d5d5d;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0,0,0,0.6);
        }
        
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
            font-weight: bold;
        }
        
        .square:hover {
            transform: scale(1.05);
            z-index: 2;
            filter: brightness(1.1);
        }
        
        .light {
            background-color: #f0d9b5;
        }
        
        .dark {
            background-color: #b58863;
        }
        
        .selected {
            background-color: #73a9ff !important;
            box-shadow: inset 0 0 20px rgba(0,100,255,0.5);
        }
        
        .possible-move {
            position: relative;
        }
        
        .possible-move::after {
            content: '';
            width: 20px;
            height: 20px;
            background-color: rgba(115, 169, 255, 0.7);
            border-radius: 50%;
            position: absolute;
            z-index: 1;
        }
        
        .capture-move::after {
            width: 45px;
            height: 45px;
            background-color: rgba(255, 100, 100, 0.5);
            border: 3px solid rgba(255, 50, 50, 0.8);
        }
        
        .check {
            background-color: rgba(255, 50, 50, 0.6) !important;
            animation: pulse 1.5s infinite;
        }
        
        .mate {
            background-color: rgba(220, 20, 20, 0.8) !important;
            animation: matePulse 0.8s infinite;
        }
        
        .king-capture {
            background-color: rgba(255, 0, 0, 0.7) !important;
            animation: kingCapture 0.5s infinite;
        }
        
        @keyframes pulse {
            0% { background-color: rgba(255, 50, 50, 0.6); }
            50% { background-color: rgba(255, 100, 100, 0.9); }
            100% { background-color: rgba(255, 50, 50, 0.6); }
        }
        
        @keyframes matePulse {
            0% { background-color: rgba(220, 20, 20, 0.8); }
            50% { background-color: rgba(255, 50, 50, 1); }
            100% { background-color: rgba(220, 20, 20, 0.8); }
        }
        
        @keyframes kingCapture {
            0% { background-color: rgba(255, 0, 0, 0.7); }
            50% { background-color: rgba(255, 100, 100, 1); }
            100% { background-color: rgba(255, 0, 0, 0.7); }
        }
        
        .info-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(40, 40, 50, 0.9);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 8px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        
        #newGameBtn {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }
        
        #undoBtn {
            background: linear-gradient(135deg, #e67e22, #d35400);
        }
        
        #hintBtn {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }
        
        #flipBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }
        
        .status {
            font-size: 18px;
            font-weight: bold;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin: 15px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255,255,255,0.15);
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        
        .piece.white {
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .piece.black {
            color: #000000;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        
        @media (max-width: 900px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .info-panel {
                width: 100%;
                max-width: 500px;
            }
        }
        
        @media (max-width: 550px) {
            #board {
                width: 350px;
                height: 350px;
            }
            
            .square {
                font-size: 30px;
            }
            
            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôõ –®–ê–•–ú–ê–¢–ù–´–ô –ë–û–¢ - –ü–†–ê–í–ò–õ–¨–ù–´–ï –®–ê–• –ò –ú–ê–¢ ‚ôö</h1>
        
        <div class="game-area">
            <div class="board-container">
                <div id="board"></div>
            </div>
            
            <div class="info-panel">
                <div class="controls">
                    <button id="newGameBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                    <button id="undoBtn">–û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
                    <button id="hintBtn">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
                    <button id="flipBtn">–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å</button>
                </div>
                
                <div class="status" id="status">–í–∞—à —Ö–æ–¥. –í—ã –∏–≥—Ä–∞–µ—Ç–µ –±–µ–ª—ã–º–∏.</div>
                
                <div style="color: #ccc; font-size: 14px; margin-top: 20px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <p><strong>–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:</strong></p>
                    <p>‚Ä¢ –ù–µ–ª—å–∑—è "—Å—ä–µ—Å—Ç—å" –∫–æ—Ä–æ–ª—è</p>
                    <p>‚Ä¢ –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ - —à–∞—Ö –∏–ª–∏ –º–∞—Ç</p>
                    <p>‚Ä¢ –ü–µ—à–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—ä—è–≤–ª—è–µ—Ç —à–∞—Ö</p>
                    <p>‚Ä¢ –ú–∞—Ç –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============= –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –î–í–ò–ñ–û–ö - –ö–û–†–û–õ–Ø –ù–ï–õ–¨–ó–Ø –°–™–ï–°–¢–¨ =============
        class ChessEngine {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.turn = 'w';
                this.history = [];
                this.gameOver = false;
                this.winner = null;
                this.check = { white: false, black: false };
                this.mate = { white: false, black: false };
            }
            
            getPiece(square) {
                const {row, col} = this.squareToCoords(square);
                return this.board[row][col];
            }
            
            squareToCoords(square) {
                const col = square.charCodeAt(0) - 97;
                const row = 8 - parseInt(square[1]);
                return {row, col};
            }
            
            coordsToSquare(row, col) {
                const file = String.fromCharCode(97 + col);
                const rank = 8 - row;
                return file + rank;
            }
            
            isWhite(piece) {
                return piece === piece.toUpperCase();
            }
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –Ω–µ–ª—å–∑—è —Ö–æ–¥–∏—Ç—å –Ω–∞ –∫–ª–µ—Ç–∫—É —Å –∫–æ—Ä–æ–ª–µ–º!
            getMovesForPiece(square) {
                const {row, col} = this.squareToCoords(square);
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const isWhite = this.isWhite(piece);
                const type = piece.toLowerCase();
                const moves = [];
                
                switch(type) {
                    case 'p':
                        const direction = isWhite ? -1 : 1;
                        const startRow = isWhite ? 6 : 1;
                        
                        // –í–ø–µ—Ä–µ–¥
                        if (this.isValidSquare(row + direction, col) && 
                            !this.board[row + direction][col]) {
                            moves.push(this.coordsToSquare(row + direction, col));
                            
                            if (row === startRow && 
                                !this.board[row + 2 * direction][col]) {
                                moves.push(this.coordsToSquare(row + 2 * direction, col));
                            }
                        }
                        
                        // –í–∑—è—Ç–∏—è (–ù–û –ù–ï –ö–û–†–û–õ–Ø!)
                        for (let dc of [-1, 1]) {
                            const newRow = row + direction;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                // –ú–û–ñ–ù–û –í–ó–Ø–¢–¨ –õ–Æ–ë–£–Æ –§–ò–ì–£–†–£, –ö–†–û–ú–ï –ö–û–†–û–õ–Ø
                                if (target && this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k') {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        }
                        break;
                        
                    case 'r':
                        moves.push(...this.getLinearMoves(row, col, [[1,0],[-1,0],[0,1],[0,-1]], isWhite));
                        break;
                        
                    case 'n':
                        const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                        knightMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || (this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k')) {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        });
                        break;
                        
                    case 'b':
                        moves.push(...this.getLinearMoves(row, col, [[1,1],[1,-1],[-1,1],[-1,-1]], isWhite));
                        break;
                        
                    case 'q':
                        moves.push(...this.getLinearMoves(row, col, 
                            [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], isWhite));
                        break;
                        
                    case 'k':
                        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
                        kingMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || (this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k')) {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        });
                        break;
                }
                
                return moves;
            }
            
            getLinearMoves(row, col, directions, isWhitePiece) {
                const moves = [];
                
                for (const [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    
                    while (this.isValidSquare(r, c)) {
                        const target = this.board[r][c];
                        if (!target) {
                            moves.push(this.coordsToSquare(r, c));
                        } else {
                            // –ù–ï–õ–¨–ó–Ø –í–ó–Ø–¢–¨ –ö–û–†–û–õ–Ø!
                            if (this.isWhite(target) !== isWhitePiece && target.toLowerCase() !== 'k') {
                                moves.push(this.coordsToSquare(r, c));
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                return moves;
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫–∏ –Ω–∞ –∫–ª–µ—Ç–∫—É (–î–õ–Ø –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –®–ê–•–ê)
            isSquareAttacked(square, byWhite) {
                const {row, col} = this.squareToCoords(square);
                
                // –ü–µ—à–∫–∏
                const pawnDirection = byWhite ? -1 : 1;
                for (let dc of [-1, 1]) {
                    const r = row + pawnDirection;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'p' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                // –ö–æ–Ω—å
                const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                for (const [dr, dc] of knightMoves) {
                    const r = row + dr;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'n' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                // –õ–∞–¥—å—è –∏ —Ñ–µ—Ä–∑—å
                const straight = [[1,0],[-1,0],[0,1],[0,-1]];
                for (const [dr, dc] of straight) {
                    let r = row + dr;
                    let c = col + dc;
                    while (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece) {
                            if ((piece.toLowerCase() === 'r' || piece.toLowerCase() === 'q') && 
                                this.isWhite(piece) === byWhite) {
                                return true;
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                // –°–ª–æ–Ω –∏ —Ñ–µ—Ä–∑—å
                const diagonal = [[1,1],[1,-1],[-1,1],[-1,-1]];
                for (const [dr, dc] of diagonal) {
                    let r = row + dr;
                    let c = col + dc;
                    while (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece) {
                            if ((piece.toLowerCase() === 'b' || piece.toLowerCase() === 'q') && 
                                this.isWhite(piece) === byWhite) {
                                return true;
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                // –ö–æ—Ä–æ–ª—å
                const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
                for (const [dr, dc] of kingMoves) {
                    const r = row + dr;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'k' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —à–∞—Ö–∞
            isKingInCheck(color) {
                let kingSquare = null;
                
                // –ù–∞—Ö–æ–¥–∏–º –∫–æ—Ä–æ–ª—è
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.toLowerCase() === 'k') {
                            const pieceColor = this.isWhite(piece) ? 'w' : 'b';
                            if (pieceColor === color) {
                                kingSquare = this.coordsToSquare(row, col);
                                break;
                            }
                        }
                    }
                    if (kingSquare) break;
                }
                
                if (!kingSquare) return false;
                
                const attackerColor = color === 'w' ? 'b' : 'w';
                return this.isSquareAttacked(kingSquare, attackerColor === 'w');
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞—Ç–∞
            isCheckmate(color) {
                // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —à–∞—Ö
                if (!this.isKingInCheck(color)) {
                    return false;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω –ª–µ–≥–∞–ª—å–Ω—ã–π —Ö–æ–¥
                const moves = this.getAllLegalMoves(color);
                return moves.length === 0;
            }
            
            // –í—Å–µ –ª–µ–≥–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã –¥–ª—è —Ü–≤–µ—Ç–∞
            getAllLegalMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && ((color === 'w' && this.isWhite(piece)) || (color === 'b' && !this.isWhite(piece)))) {
                            const fromSquare = this.coordsToSquare(row, col);
                            const pieceMoves = this.getMovesForPiece(fromSquare);
                            
                            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ª–µ–≥–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã
                            for (const to of pieceMoves) {
                                if (this.isMoveLegal(fromSquare, to)) {
                                    moves.push({from: fromSquare, to});
                                }
                            }
                        }
                    }
                }
                return moves;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–µ–≥–∞–ª—å–Ω–æ—Å—Ç–∏ —Ö–æ–¥–∞
            isMoveLegal(from, to) {
                // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –¥–æ—Å–∫–∏
                const testBoard = new ChessEngine();
                testBoard.board = JSON.parse(JSON.stringify(this.board));
                
                const fromCoords = this.squareToCoords(from);
                const toCoords = this.squareToCoords(to);
                const piece = testBoard.board[fromCoords.row][fromCoords.col];
                
                if (!piece) return false;
                
                const isWhitePiece = this.isWhite(piece);
                const pieceColor = isWhitePiece ? 'w' : 'b';
                
                // –¶–µ–ª—å - –∫–æ—Ä–æ–ª—å? –≠—Ç–æ —à–∞—Ö, –∞ –Ω–µ –≤–∑—è—Ç–∏–µ!
                const targetPiece = testBoard.board[toCoords.row][toCoords.col];
                if (targetPiece && targetPiece.toLowerCase() === 'k') {
                    // –≠—Ç–æ —à–∞—Ö! –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –µ–≥–æ –æ–±—ä—è–≤–∏—Ç—å
                    // (—Ñ–∏–≥—É—Ä–∞ –º–æ–∂–µ—Ç –∞—Ç–∞–∫–æ–≤–∞—Ç—å –∫–æ—Ä–æ–ª—è)
                    return true; // –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–∞–∫–æ–π —Ö–æ–¥ - —ç—Ç–æ –±—É–¥–µ—Ç —à–∞—Ö
                }
                
                // –ü—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
                testBoard.board[toCoords.row][toCoords.col] = piece;
                testBoard.board[fromCoords.row][fromCoords.col] = '';
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Å—Ç–∞–ª—Å—è –ª–∏ –Ω–∞—à –∫–æ—Ä–æ–ª—å –ø–æ–¥ —à–∞—Ö–æ–º
                return !testBoard.isKingInCheck(pieceColor);
            }
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î –•–û–î–ê
            move(from, to) {
                if (this.gameOver) {
                    console.log("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞, —Ö–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω");
                    return null;
                }
                
                const fromCoords = this.squareToCoords(from);
                const toCoords = this.squareToCoords(to);
                
                const piece = this.board[fromCoords.row][fromCoords.col];
                if (!piece) {
                    console.log("–ù–µ—Ç —Ñ–∏–≥—É—Ä—ã –Ω–∞ –∫–ª–µ—Ç–∫–µ", from);
                    return null;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á–µ–π —Ö–æ–¥
                const pieceColor = this.isWhite(piece) ? 'w' : 'b';
                if (this.turn !== pieceColor) {
                    console.log("–ù–µ –≤–∞—à —Ö–æ–¥. –û–∂–∏–¥–∞–µ—Ç—Å—è:", this.turn, "–∞ —Ñ–∏–≥—É—Ä–∞:", pieceColor);
                    return null;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–µ–≥–∞–ª—å–Ω–æ—Å—Ç—å —Ö–æ–¥–∞
                if (!this.isMoveLegal(from, to)) {
                    console.log("–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ö–æ–¥:", from, "->", to);
                    return null;
                }
                
                const targetPiece = this.board[toCoords.row][toCoords.col];
                
                // –û–°–û–ë–´–ô –°–õ–£–ß–ê–ô: —Ü–µ–ª—å - –∫–æ—Ä–æ–ª—å! –≠—Ç–æ —à–∞—Ö!
                if (targetPiece && targetPiece.toLowerCase() === 'k') {
                    console.log("–®–ê–•! –§–∏–≥—É—Ä–∞", piece, "–∞—Ç–∞–∫—É–µ—Ç –∫–æ—Ä–æ–ª—è –Ω–∞", to);
                    
                    // –°–Ω–∞—á–∞–ª–∞ –¥–µ–ª–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ö–æ–¥ (–∫–æ—Ä–æ–ª—å –Ω–µ —Å—ä–µ–¥–∞–µ—Ç—Å—è!)
                    const moveInfo = {
                        from: from,
                        to: to,
                        piece: piece,
                        captured: null, // –ö–æ—Ä–æ–ª—è –Ω–µ —Å—ä–µ–¥–∞–µ–º!
                        check: true,    // –≠—Ç–æ —à–∞—Ö!
                        mate: false
                    };
                    
                    // –î–µ–ª–∞–µ–º —Ö–æ–¥ (–Ω–æ –∫–æ—Ä–æ–ª—å –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–µ!)
                    this.board[toCoords.row][toCoords.col] = piece;
                    this.board[fromCoords.row][fromCoords.col] = '';
                    
                    // –ú–µ–Ω—è–µ–º —Ö–æ–¥
                    this.turn = this.turn === 'w' ? 'b' : 'w';
                    this.history.push(moveInfo);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —à–∞—Ö–∞
                    this.check.white = this.isKingInCheck('w');
                    this.check.black = this.isKingInCheck('b');
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç
                    this.mate.white = this.isCheckmate('w');
                    this.mate.black = this.isCheckmate('b');
                    
                    if (this.mate.white || this.mate.black) {
                        this.gameOver = true;
                        this.winner = this.mate.white ? 'black' : 'white';
                        moveInfo.mate = true;
                        console.log("–®–ê–• –ò –ú–ê–¢! –ü–æ–±–µ–¥–∏–ª–∏", this.winner);
                    }
                    
                    return moveInfo;
                }
                
                // –û–±—ã—á–Ω—ã–π —Ö–æ–¥ (–Ω–µ –Ω–∞ –∫–æ—Ä–æ–ª—è)
                const moveInfo = {
                    from: from,
                    to: to,
                    piece: piece,
                    captured: targetPiece,
                    check: false,
                    mate: false
                };
                
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
                this.board[toCoords.row][toCoords.col] = piece;
                this.board[fromCoords.row][fromCoords.col] = '';
                
                // –ú–µ–Ω—è–µ–º —Ö–æ–¥
                this.turn = this.turn === 'w' ? 'b' : 'w';
                this.history.push(moveInfo);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —à–∞—Ö–∞
                this.check.white = this.isKingInCheck('w');
                this.check.black = this.isKingInCheck('b');
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç
                this.mate.white = this.isCheckmate('w');
                this.mate.black = this.isCheckmate('b');
                
                if (this.mate.white || this.mate.black) {
                    this.gameOver = true;
                    this.winner = this.mate.white ? 'black' : 'white';
                    moveInfo.mate = true;
                    console.log("–®–ê–• –ò –ú–ê–¢! –ü–æ–±–µ–¥–∏–ª–∏", this.winner);
                }
                
                return moveInfo;
            }
            
            undo() {
                if (this.history.length === 0) return null;
                
                const lastMove = this.history.pop();
                const fromCoords = this.squareToCoords(lastMove.from);
                const toCoords = this.squareToCoords(lastMove.to);
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏–≥—É—Ä—É
                this.board[fromCoords.row][fromCoords.col] = lastMove.piece;
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–∑—è—Ç—É—é —Ñ–∏–≥—É—Ä—É (–µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞)
                if (lastMove.captured) {
                    this.board[toCoords.row][toCoords.col] = lastMove.captured;
                } else {
                    this.board[toCoords.row][toCoords.col] = '';
                }
                
                // –ú–µ–Ω—è–µ–º —Ö–æ–¥ –æ–±—Ä–∞—Ç–Ω–æ
                this.turn = this.turn === 'w' ? 'b' : 'w';
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
                this.gameOver = false;
                this.winner = null;
                this.check.white = this.isKingInCheck('w');
                this.check.black = this.isKingInCheck('b');
                this.mate.white = false;
                this.mate.black = false;
                
                return lastMove;
            }
            
            // –ü–†–û–°–¢–û–ô –ë–û–¢
            findBestMoveForBot() {
                const moves = this.getAllLegalMoves('b');
                if (moves.length === 0) return null;
                
                let bestMove = null;
                let bestScore = -Infinity;
                
                // –ï—Å–ª–∏ —à–∞—Ö - –∑–∞—â–∏—â–∞–µ–º—Å—è
                if (this.check.black) {
                    console.log("–ë–æ—Ç –ø–æ–¥ —à–∞—Ö–æ–º! –ó–∞—â–∏—â–∞—é—Å—å...");
                    
                    for (const move of moves) {
                        let score = 0;
                        
                        // –¢–µ—Å—Ç–æ–≤–∞—è –¥–æ—Å–∫–∞
                        const testBoard = new ChessEngine();
                        testBoard.board = JSON.parse(JSON.stringify(this.board));
                        
                        const targetPiece = this.getPiece(move.to);
                        const movingPiece = this.getPiece(move.from);
                        
                        // –ü—Ä–æ–±—É–µ–º —Ö–æ–¥
                        const moveResult = testBoard.move(move.from, move.to);
                        if (!moveResult) continue;
                        
                        // –£–®–ï–õ –û–¢ –®–ê–•–ê? (—Å–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ!)
                        if (!testBoard.isKingInCheck('b')) {
                            score += 1000;
                        } else {
                            continue; // –í—Å–µ –µ—â–µ –ø–æ–¥ —à–∞—Ö–æ–º - –ø–ª–æ—Ö–æ–π —Ö–æ–¥
                        }
                        
                        // –í–∑—è—Ç–∏–µ —Ñ–∏–≥—É—Ä—ã
                        if (targetPiece) {
                            const pieceValues = {
                                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9
                            };
                            const value = pieceValues[targetPiece.toLowerCase()] || 0;
                            score += value * 10;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                // –ï—Å–ª–∏ –Ω–µ—Ç —à–∞—Ö–∞ –∏–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∑–∞—â–∏—Ç—É - –∞—Ç–∞–∫—É–µ–º
                if (!bestMove) {
                    console.log("–ë–æ—Ç –∞—Ç–∞–∫—É–µ—Ç...");
                    
                    for (const move of moves) {
                        let score = 0;
                        
                        const targetPiece = this.getPiece(move.to);
                        const movingPiece = this.getPiece(move.from);
                        
                        // –í–∑—è—Ç–∏–µ —Ñ–∏–≥—É—Ä—ã
                        if (targetPiece) {
                            const pieceValues = {
                                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9
                            };
                            const value = pieceValues[targetPiece.toLowerCase()] || 0;
                            score += value * 10;
                            
                            // –û—Å–æ–±—ã–π –±–æ–Ω—É—Å –∑–∞ –≤–∑—è—Ç–∏–µ —Ñ–µ—Ä–∑—è
                            if (targetPiece.toLowerCase() === 'q') {
                                score += 500;
                            }
                        }
                        
                        // –®–∞—Ö –∫–æ—Ä–æ–ª—é –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                        const testBoard = new ChessEngine();
                        testBoard.board = JSON.parse(JSON.stringify(this.board));
                        const moveResult = testBoard.move(move.from, move.to);
                        
                        if (moveResult && moveResult.check) {
                            score += 100; // –ë–æ–ª—å—à–æ–π –±–æ–Ω—É—Å –∑–∞ —à–∞—Ö
                        }
                        
                        // –ö–æ–Ω—Ç—Ä–æ–ª—å —Ü–µ–Ω—Ç—Ä–∞
                        const centerSquares = ['d4', 'd5', 'e4', 'e5'];
                        if (centerSquares.includes(move.to)) {
                            score += 3;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                return bestMove || moves[0];
            }
        }
        
        // ============= –ì–õ–ê–í–ù–´–ô –°–ö–†–ò–ü–¢ =============
        const chess = new ChessEngine();
        let selectedSquare = null;
        let possibleMoves = [];
        let boardFlipped = false;
        
        const pieceSymbols = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };
        
        function initBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    
                    const file = String.fromCharCode(97 + col);
                    const rank = 8 - row;
                    const squareName = file + rank;
                    square.dataset.square = squareName;
                    
                    const isLight = (row + col) % 2 === 0;
                    square.classList.add(isLight ? 'light' : 'dark');
                    
                    square.addEventListener('click', () => handleSquareClick(squareName));
                    board.appendChild(square);
                }
            }
            
            updateBoard();
            updateStatus();
        }
        
        function updateBoard() {
            // –û—á–∏—â–∞–µ–º –¥–æ—Å–∫—É
            document.querySelectorAll('.square').forEach(sq => {
                const oldPiece = sq.querySelector('.piece');
                if (oldPiece) oldPiece.remove();
                
                sq.classList.remove('selected', 'possible-move', 'capture-move', 'check', 'mate', 'king-capture');
            });
            
            // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º —Ñ–∏–≥—É—Ä—ã
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chess.board[row][col];
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                    
                    if (square && piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.textContent = pieceSymbols[piece];
                        pieceEl.className = `piece ${chess.isWhite(piece) ? 'white' : 'black'}`;
                        square.appendChild(pieceEl);
                    }
                }
            }
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —à–∞—Ö–∏
            if (chess.check.white) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === 'K') {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('check');
                        }
                    }
                }
            }
            
            if (chess.check.black) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === 'k') {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('check');
                        }
                    }
                }
            }
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –º–∞—Ç—ã
            if (chess.mate.white || chess.mate.black) {
                const color = chess.mate.white ? 'white' : 'black';
                const kingSymbol = color === 'white' ? 'K' : 'k';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === kingSymbol) {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('mate');
                        }
                    }
                }
            }
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–ª–µ—Ç–∫—É
            if (selectedSquare) {
                const squareEl = document.querySelector(`[data-square="${selectedSquare}"]`);
                if (squareEl) squareEl.classList.add('selected');
            }
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
            possibleMoves.forEach(move => {
                const squareEl = document.querySelector(`[data-square="${move}"]`);
                if (squareEl) {
                    squareEl.classList.add('possible-move');
                    
                    const targetPiece = chess.getPiece(move);
                    if (targetPiece) {
                        // –û–°–û–ë–û–ï –ü–û–î–°–í–ï–ß–ò–í–ê–ù–ò–ï –î–õ–Ø –ê–¢–ê–ö–ò –ù–ê –ö–û–†–û–õ–Ø
                        if (targetPiece.toLowerCase() === 'k') {
                            squareEl.classList.add('king-capture');
                        } else {
                            squareEl.classList.add('capture-move');
                        }
                    }
                }
            });
            
            // –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –¥–æ—Å–∫–∏
            if (boardFlipped) {
                document.getElementById('board').style.transform = 'rotate(180deg)';
                document.querySelectorAll('.square').forEach(sq => {
                    sq.style.transform = 'rotate(180deg)';
                });
            } else {
                document.getElementById('board').style.transform = 'rotate(0deg)';
                document.querySelectorAll('.square').forEach(sq => {
                    sq.style.transform = 'rotate(0deg)';
                });
            }
        }
        
        function handleSquareClick(square) {
            if (chess.gameOver) {
                alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! ${chess.winner ? `–ü–æ–±–µ–¥–∏–ª–∏ ${chess.winner === 'white' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'}!` : '–ù–∏—á—å—è!'}`);
                return;
            }
            
            // –ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ –≤–æ–∑–º–æ–∂–Ω—ã–π —Ö–æ–¥
            if (possibleMoves.includes(square)) {
                makeMove(selectedSquare, square);
                return;
            }
            
            const piece = chess.getPiece(square);
            if (!piece) {
                selectedSquare = null;
                possibleMoves = [];
                updateBoard();
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á–µ–π —Ö–æ–¥
            const pieceColor = chess.isWhite(piece) ? 'w' : 'b';
            if (chess.turn !== pieceColor) {
                alert("–ù–µ –≤–∞—à —Ö–æ–¥!");
                return;
            }
            
            // –í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–≥—É—Ä—É –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
            selectedSquare = square;
            possibleMoves = chess.getMovesForPiece(square);
            
            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ª–µ–≥–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã
            possibleMoves = possibleMoves.filter(move => chess.isMoveLegal(square, move));
            
            updateBoard();
        }
        
        function makeMove(from, to) {
            console.log("–ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥:", from, "->", to);
            
            const move = chess.move(from, to);
            if (!move) {
                console.log("–•–æ–¥ –Ω–µ —É–¥–∞–ª—Å—è");
                selectedSquare = null;
                possibleMoves = [];
                updateBoard();
                return;
            }
            
            console.log("–•–æ–¥ —É—Å–ø–µ—à–µ–Ω:", move);
            
            selectedSquare = null;
            possibleMoves = [];
            
            updateBoard();
            updateStatus();
            
            // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –•–û–î –ë–û–¢–ê
            if (!chess.gameOver && chess.turn === 'b') {
                setTimeout(makeBotMove, 800);
            }
        }
        
        function makeBotMove() {
            console.log("=== –ë–û–¢ –î–ï–õ–ê–ï–¢ –•–û–î ===");
            
            if (chess.gameOver) {
                console.log("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞");
                return;
            }
            
            const bestMove = chess.findBestMoveForBot();
            
            if (bestMove) {
                console.log("–ë–æ—Ç –≤—ã–±—Ä–∞–ª:", bestMove.from, "->", bestMove.to);
                chess.move(bestMove.from, bestMove.to);
                updateBoard();
                updateStatus();
            } else {
                console.log("–ë–æ—Ç –Ω–µ –Ω–∞—à–µ–ª —Ö–æ–¥");
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ç –∏–ª–∏ –ø–∞—Ç
                if (chess.check.black) {
                    chess.mate.black = true;
                    chess.gameOver = true;
                    chess.winner = 'white';
                    updateStatus();
                    updateBoard();
                }
            }
            
            console.log("=== –•–û–î –ë–û–¢–ê –ó–ê–í–ï–†–®–ï–ù ===");
        }
        
        function updateStatus() {
            const status = document.getElementById('status');
            
            if (chess.gameOver) {
                if (chess.winner) {
                    status.textContent = `üèÜ –®–ê–• –ò –ú–ê–¢! –ü–æ–±–µ–¥–∏–ª–∏ ${chess.winner === 'white' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'}!`;
                } else {
                    status.textContent = 'ü§ù –ü–∞—Ç! –ù–∏—á—å—è!';
                }
                return;
            }
            
            if (chess.turn === 'w') {
                status.textContent = '‚úÖ –í–∞—à —Ö–æ–¥ (–±–µ–ª—ã–µ)';
                if (chess.check.white) {
                    status.textContent += ' - ‚ö†Ô∏è –í–ê–® –ö–û–†–û–õ–¨ –ü–û–î –®–ê–•–û–ú!';
                }
            } else {
                status.textContent = 'ü§ñ –•–æ–¥ –±–æ—Ç–∞ (—á–µ—Ä–Ω—ã–µ)...';
                if (chess.check.black) {
                    status.textContent += ' - ‚ö†Ô∏è –®–ê–•! (–±–æ—Ç –∑–∞—â–∏—â–∞–µ—Ç—Å—è)';
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        document.getElementById('newGameBtn').addEventListener('click', () => {
            chess.reset();
            selectedSquare = null;
            possibleMoves = [];
            updateBoard();
            updateStatus();
        });
        
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (chess.history.length >= 2) {
                chess.undo(); // –•–æ–¥ –±–æ—Ç–∞
                chess.undo(); // –•–æ–¥ –∏–≥—Ä–æ–∫–∞
            }
            selectedSquare = null;
            possibleMoves = [];
            updateBoard();
            updateStatus();
        });
        
        document.getElementById('hintBtn').addEventListener('click', () => {
            alert("–ß—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —à–∞—Ö –ø–µ—à–∫–æ–π:\n1. –û—Ç–∫—Ä–æ–π—Ç–µ –ª–∏–Ω–∏—é –∫ –∫–æ—Ä–æ–ª—é\n2. –ê—Ç–∞–∫—É–π—Ç–µ –∫–æ—Ä–æ–ª—è –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏\n3. –ö–æ—Ä–æ–ª—å –ø–æ–¥—Å–≤–µ—Ç–∏—Ç—Å—è –∫—Ä–∞—Å–Ω—ã–º - —ç—Ç–æ —à–∞—Ö!\n4. –ï—Å–ª–∏ –∑–∞—â–∏—Ç—ã –Ω–µ—Ç - —ç—Ç–æ –º–∞—Ç!");
        });
        
        document.getElementById('flipBtn').addEventListener('click', () => {
            boardFlipped = !boardFlipped;
            updateBoard();
        });
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('DOMContentLoaded', initBoard);

    </script>
</body>
</html>