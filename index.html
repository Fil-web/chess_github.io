<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç–Ω—ã–π –±–æ—Ç</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1929, #1a2c42, #2c3e50);
            color: white;
            text-align: center;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(20, 25, 35, 0.95);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7);
            border: 1px solid rgba(100, 150, 255, 0.2);
            backdrop-filter: blur(10px);
            animation: containerAppear 0.8s ease-out;
        }
        
        @keyframes containerAppear {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            color: #fff;
            margin-bottom: 25px;
            font-size: 2.5em;
            text-shadow: 0 3px 15px rgba(0,0,0,0.7);
            background: linear-gradient(90deg, #ffd700, #ffed4e, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            padding-bottom: 15px;
            border-bottom: 3px solid rgba(100, 150, 255, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        h1::after {
            content: '‚ôî‚ôõ‚ôö‚ôï';
            position: absolute;
            top: 0;
            right: 20px;
            opacity: 0.2;
            font-size: 1.5em;
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin: 25px 0;
        }
        
        .board-container {
            position: relative;
            background: rgba(0, 5, 15, 0.4);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 100, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .board-container:hover {
            box-shadow: 0 0 40px rgba(0, 150, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.4);
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 550px;
            height: 550px;
            border: 4px solid #4a6186;
            border-radius: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            background: #1a2332;
            position: relative;
            overflow: hidden;
        }
        
        #board::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, transparent 30%, rgba(100, 150, 255, 0.1) 50%, transparent 70%);
            animation: boardGlow 4s infinite linear;
            z-index: 0;
        }
        
        @keyframes boardGlow {
            0% { transform: translateX(-100%) translateY(-100%); }
            100% { transform: translateX(100%) translateY(100%); }
        }
        
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 45px;
            cursor: pointer;
            user-select: none;
            transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            font-weight: bold;
            z-index: 1;
        }
        
        .square:hover {
            transform: scale(1.08);
            z-index: 3;
            filter: brightness(1.15);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        
        .light {
            background: linear-gradient(135deg, #f0d9b5, #e8cfa5);
        }
        
        .dark {
            background: linear-gradient(135deg, #b58863, #a07850);
        }
        
        .selected {
            background: linear-gradient(135deg, #73a9ff, #5c8aff) !important;
            box-shadow: inset 0 0 25px rgba(0,100,255,0.6), 0 0 20px rgba(115, 169, 255, 0.5) !important;
            transform: scale(1.05);
        }
        
        .possible-move {
            position: relative;
        }
        
        .possible-move::after {
            content: '';
            width: 22px;
            height: 22px;
            background: radial-gradient(circle, rgba(115, 169, 255, 0.9) 30%, rgba(115, 169, 255, 0.3) 70%);
            border-radius: 50%;
            position: absolute;
            z-index: 2;
            animation: movePulse 1.5s infinite;
        }
        
        @keyframes movePulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }
        
        .capture-move::after {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6) 20%, rgba(255, 50, 50, 0.3) 60%);
            border: 3px solid rgba(255, 50, 50, 0.9);
            animation: capturePulse 1s infinite;
        }
        
        @keyframes capturePulse {
            0%, 100% { transform: scale(1); border-width: 3px; }
            50% { transform: scale(1.1); border-width: 4px; }
        }
        
        .castle-move::after {
            content: 'üè∞';
            font-size: 30px;
            position: absolute;
            z-index: 2;
            animation: castlePulse 2s infinite;
        }
        
        @keyframes castlePulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        .check {
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.7), rgba(255, 100, 100, 0.8)) !important;
            animation: checkPulse 2s infinite;
        }
        
        @keyframes checkPulse {
            0% { box-shadow: inset 0 0 30px rgba(255, 50, 50, 0.7); }
            50% { box-shadow: inset 0 0 40px rgba(255, 100, 100, 0.9); }
            100% { box-shadow: inset 0 0 30px rgba(255, 50, 50, 0.7); }
        }
        
        .mate {
            background: linear-gradient(135deg, rgba(220, 20, 20, 0.9), rgba(255, 50, 50, 0.9)) !important;
            animation: matePulse 0.8s infinite;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.7) !important;
        }
        
        @keyframes matePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        
        .king-attack {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.8), rgba(255, 100, 100, 0.9)) !important;
            animation: kingAttack 0.5s infinite alternate;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.6);
        }
        
        @keyframes kingAttack {
            0% { background: rgba(255, 0, 0, 0.8); }
            100% { background: rgba(255, 100, 100, 0.9); }
        }
        
        .info-panel {
            flex: 1;
            min-width: 350px;
            background: linear-gradient(135deg, rgba(30, 35, 45, 0.95), rgba(40, 45, 55, 0.95));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            border: 1px solid rgba(100, 150, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 14px 10px;
            font-size: 16px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            filter: brightness(1.15);
        }
        
        button:active {
            transform: translateY(-1px);
            transition: 0.1s;
        }
        
        #newGameBtn {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }
        
        #undoBtn {
            background: linear-gradient(135deg, #e67e22, #d35400);
        }
        
        #hintBtn {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }
        
        #flipBtn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }
        
        .status {
            font-size: 20px;
            font-weight: bold;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 10, 20, 0.6), rgba(0, 20, 40, 0.6));
            border-radius: 12px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(100, 150, 255, 0.2);
            text-shadow: 0 2px 10px rgba(0,0,0,0.7);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }
        
        .status.warning {
            background: linear-gradient(135deg, rgba(200, 50, 0, 0.6), rgba(255, 100, 0, 0.6));
            animation: statusPulse 2s infinite;
        }
        
        .status.victory {
            background: linear-gradient(135deg, rgba(0, 150, 50, 0.7), rgba(50, 200, 100, 0.7));
            animation: victoryPulse 1s infinite;
        }
        
        .status.draw {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.7), rgba(255, 152, 0, 0.7));
            animation: drawPulse 1.5s infinite;
        }
        
        @keyframes statusPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 100, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 150, 0, 0.5); }
        }
        
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        @keyframes drawPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 193, 7, 0.3); }
            50% { transform: scale(1.01); box-shadow: 0 0 25px rgba(255, 193, 7, 0.5); }
        }
        
        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }
        
        .info-box {
            background: rgba(0, 10, 25, 0.6);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            text-align: left;
        }
        
        .info-box h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 5px;
        }
        
        .info-box p {
            font-size: 14px;
            line-height: 1.4;
            color: #ccc;
        }
        
        .timer-display {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
        }
        
        .white-timer {
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            padding: 5px 15px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            margin-bottom: 8px;
        }
        
        .black-timer {
            color: #aaa;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
        }
        
        .timer-low {
            color: #ff6b6b !important;
            animation: timerPulse 0.5s infinite;
        }
        
        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .piece-count {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 18px;
        }
        
        .white-pieces { color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .black-pieces { color: #000; text-shadow: 0 0 10px rgba(255,255,255,0.8); }
        
        .piece.white {
            color: #ffffff;
            text-shadow: 3px 3px 8px rgba(0,0,0,0.9), 0 0 15px rgba(255,255,255,0.5);
            transition: all 0.2s;
        }
        
        .piece.black {
            color: #000000;
            text-shadow: 3px 3px 8px rgba(255,255,255,0.9), 0 0 15px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        
        .piece.selected-piece {
            animation: pieceFloat 2s infinite ease-in-out;
        }
        
        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .move-history {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 5, 15, 0.5);
            border-radius: 8px;
            padding: 10px;
            text-align: left;
            font-size: 14px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .move-entry {
            padding: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
        }
        
        .move-entry:last-child {
            border-bottom: none;
        }
        
        .move-number {
            color: #ffd700;
            min-width: 30px;
        }
        
        .move-white {
            color: #fff;
        }
        
        .move-black {
            color: #aaa;
        }
        
        .move-check {
            color: #ff6b6b !important;
            font-weight: bold;
        }
        
        .move-mate {
            color: #ff0000 !important;
            font-weight: bold;
            animation: textPulse 1s infinite;
        }
        
        .move-castle {
            color: #4ecdc4 !important;
            font-weight: bold;
        }
        
        .move-promotion {
            color: #ff9ff3 !important;
            font-weight: bold;
        }
        
        @keyframes textPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .turn-white, .turn-black {
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .turn-white.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }
        
        .turn-black.active {
            background: linear-gradient(135deg, #e67e22, #d35400);
            box-shadow: 0 0 20px rgba(230, 126, 34, 0.5);
        }
        
        @media (max-width: 1000px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .info-panel {
                width: 100%;
                max-width: 550px;
            }
            
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 600px) {
            #board {
                width: 95vw;
                height: 95vw;
                max-width: 450px;
                max-height: 450px;
            }
            
            .square {
                font-size: 35px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
        }
        
        .bot-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid #3498db;
            z-index: 100;
            display: none;
            font-weight: bold;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5);
            animation: botThinking 2s infinite;
        }
        
        @keyframes botThinking {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .sound-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(40, 45, 55, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 2px solid rgba(100, 150, 255, 0.3);
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .sound-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .promotion-options {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
            text-align: center;
            min-width: 300px;
        }
        
        .promotion-options h3 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .promotion-piece {
            font-size: 50px;
            margin: 10px;
            padding: 15px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .promotion-piece:hover {
            background: rgba(255, 215, 0, 0.3);
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .promotion-piece.white {
            color: white;
            text-shadow: 0 0 10px white;
        }
        
        .promotion-piece.black {
            color: black;
            text-shadow: 0 0 10px white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî –®–ê–•–ú–ê–¢–ù–´–ô –ë–û–¢ ‚ôö</h1>
        
        <div class="turn-indicator">
            <div class="turn-white active">–ë–ï–õ–´–ï</div>
            <div class="turn-black">–ß–ï–†–ù–´–ï</div>
        </div>
        
        <div class="game-area">
            <div class="board-container">
                <div id="board"></div>
                <div class="bot-thinking" id="botThinking">ü§ñ –ë–æ—Ç –¥—É–º–∞–µ—Ç...</div>
            </div>
            
            <div class="info-panel">
                <div class="controls">
                    <button id="newGameBtn">‚ôªÔ∏è –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                    <button id="undoBtn">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
                    <button id="hintBtn">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
                    <button id="flipBtn">üîÑ –ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å</button>
                </div>
                
                <div class="status" id="status">
                    <span>–í–∞—à —Ö–æ–¥. –í—ã –∏–≥—Ä–∞–µ—Ç–µ –±–µ–ª—ã–º–∏.</span>
                </div>
                
                <div class="game-info">
                    <div class="info-box">
                        <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
                        <div class="piece-count">
                            <div class="white-pieces" id="whitePieces">–ë–µ–ª—ã–µ: 16</div>
                            <div class="black-pieces" id="blackPieces">–ß–µ—Ä–Ω—ã–µ: 16</div>
                        </div>
                        <p>–•–æ–¥: <span id="moveCount">1</span></p>
                        <div class="timer-display">
                            <div class="white-timer" id="whiteTimer">01:00</div>
                            <div class="black-timer" id="blackTimer">01:00</div>
                        </div>
                        <p id="castleStatus">–†–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞</p>
                    </div>
                    
                    <div class="info-box">
                        <h3>üìù –ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</h3>
                        <div class="move-history" id="moveHistory">
                            <div class="move-entry"><span class="move-number">1.</span> <span class="move-white">-</span> <span class="move-black">-</span></div>
                        </div>
                    </div>
                </div>
                
                <div style="color: #ddd; font-size: 14px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <p><strong>üéØ –§—É–Ω–∫—Ü–∏–∏:</strong></p>
                    <p>‚Ä¢ –†–æ–∫–∏—Ä–æ–≤–∫–∞ (–¥–ª–∏–Ω–Ω–∞—è –∏ –∫–æ—Ä–æ—Ç–∫–∞—è)</p>
                    <p>‚Ä¢ –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏ –≤ —Ñ–µ—Ä–∑—è, –ª–∞–¥—å—é, —Å–ª–æ–Ω–∞ –∏–ª–∏ –∫–æ–Ω—è</p>
                    <p>‚Ä¢ –¢–∞–π–º–µ—Ä –Ω–∞ 1 –º–∏–Ω—É—Ç—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–≥—Ä–æ–∫–∞</p>
                    <p>‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∞—Ç–∞ –∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞</p>
                    <p>‚Ä¢ –ë–æ—Ç —Ç–æ–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å–µ –ø—Ä–∞–≤–∏–ª–∞</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-options">
            <h3>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è:</h3>
            <div class="promotion-piece white" data-piece="Q">‚ôï</div>
            <div class="promotion-piece white" data-piece="R">‚ôñ</div>
            <div class="promotion-piece white" data-piece="B">‚ôó</div>
            <div class="promotion-piece white" data-piece="N">‚ôò</div>
        </div>
    </div>
    
    <div class="sound-toggle" id="soundToggle">üîä</div>

    <script>
        // ============= –®–ê–•–ú–ê–¢–ù–´–ô –î–í–ò–ñ–û–ö –° –†–û–ö–ò–†–û–í–ö–û–ô –ò –ü–†–ï–í–†–ê–©–ï–ù–ò–ï–ú =============
        class ChessEngine {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.turn = 'w';
                this.history = [];
                this.gameOver = false;
                this.winner = null;
                this.check = { white: false, black: false };
                this.mate = { white: false, black: false };
                this.stalemate = false;
                
                // –§–ª–∞–≥–∏ –¥–ª—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
                this.castlingRights = {
                    white: { king: true, queenside: true, kingside: true },
                    black: { king: true, queenside: true, kingside: true }
                };
                
                // –î–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—à–∫–∏
                this.pawnToPromote = null;
            }
            
            getPiece(square) {
                const {row, col} = this.squareToCoords(square);
                return this.board[row][col];
            }
            
            squareToCoords(square) {
                const col = square.charCodeAt(0) - 97;
                const row = 8 - parseInt(square[1]);
                return {row, col};
            }
            
            coordsToSquare(row, col) {
                const file = String.fromCharCode(97 + col);
                const rank = 8 - row;
                return file + rank;
            }
            
            isWhite(piece) {
                return piece === piece.toUpperCase();
            }
            
            getMovesForPiece(square) {
                const {row, col} = this.squareToCoords(square);
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const isWhite = this.isWhite(piece);
                const type = piece.toLowerCase();
                const moves = [];
                
                switch(type) {
                    case 'p':
                        const direction = isWhite ? -1 : 1;
                        const startRow = isWhite ? 6 : 1;
                        const promotionRow = isWhite ? 0 : 7;
                        
                        // –í–ø–µ—Ä–µ–¥
                        if (this.isValidSquare(row + direction, col) && 
                            !this.board[row + direction][col]) {
                            moves.push(this.coordsToSquare(row + direction, col));
                            
                            if (row === startRow && 
                                !this.board[row + 2 * direction][col]) {
                                moves.push(this.coordsToSquare(row + 2 * direction, col));
                            }
                        }
                        
                        // –í–∑—è—Ç–∏—è
                        for (let dc of [-1, 1]) {
                            const newRow = row + direction;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (target && this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k') {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        }
                        break;
                        
                    case 'r':
                        moves.push(...this.getLinearMoves(row, col, [[1,0],[-1,0],[0,1],[0,-1]], isWhite));
                        break;
                        
                    case 'n':
                        const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                        knightMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || (this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k')) {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        });
                        break;
                        
                    case 'b':
                        moves.push(...this.getLinearMoves(row, col, [[1,1],[1,-1],[-1,1],[-1,-1]], isWhite));
                        break;
                        
                    case 'q':
                        moves.push(...this.getLinearMoves(row, col, 
                            [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], isWhite));
                        break;
                        
                    case 'k':
                        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
                        kingMoves.forEach(([dr, dc]) => {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidSquare(newRow, newCol)) {
                                const target = this.board[newRow][newCol];
                                if (!target || (this.isWhite(target) !== isWhite && target.toLowerCase() !== 'k')) {
                                    moves.push(this.coordsToSquare(newRow, newCol));
                                }
                            }
                        });
                        
                        // –†–û–ö–ò–†–û–í–ö–ê
                        if (!this.check[isWhite ? 'white' : 'black']) {
                            const color = isWhite ? 'white' : 'black';
                            const rights = this.castlingRights[color];
                            
                            if (rights.king && rights.kingside) {
                                // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (–≤ —Å—Ç–æ—Ä–æ–Ω—É –∫–æ—Ä–æ–ª—è)
                                if (isWhite) {
                                    if (!this.board[7][5] && !this.board[7][6] && 
                                        this.board[7][7] === 'R' &&
                                        !this.isSquareAttacked('f1', false) &&
                                        !this.isSquareAttacked('g1', false)) {
                                        moves.push(this.coordsToSquare(7, 6));
                                    }
                                } else {
                                    if (!this.board[0][5] && !this.board[0][6] && 
                                        this.board[0][7] === 'r' &&
                                        !this.isSquareAttacked('f8', true) &&
                                        !this.isSquareAttacked('g8', true)) {
                                        moves.push(this.coordsToSquare(0, 6));
                                    }
                                }
                            }
                            
                            if (rights.king && rights.queenside) {
                                // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (–≤ —Å—Ç–æ—Ä–æ–Ω—É —Ñ–µ—Ä–∑—è)
                                if (isWhite) {
                                    if (!this.board[7][1] && !this.board[7][2] && !this.board[7][3] && 
                                        this.board[7][0] === 'R' &&
                                        !this.isSquareAttacked('d1', false) &&
                                        !this.isSquareAttacked('c1', false)) {
                                        moves.push(this.coordsToSquare(7, 2));
                                    }
                                } else {
                                    if (!this.board[0][1] && !this.board[0][2] && !this.board[0][3] && 
                                        this.board[0][0] === 'r' &&
                                        !this.isSquareAttacked('d8', true) &&
                                        !this.isSquareAttacked('c8', true)) {
                                        moves.push(this.coordsToSquare(0, 2));
                                    }
                                }
                            }
                        }
                        break;
                }
                
                return moves;
            }
            
            getLinearMoves(row, col, directions, isWhitePiece) {
                const moves = [];
                
                for (const [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    
                    while (this.isValidSquare(r, c)) {
                        const target = this.board[r][c];
                        if (!target) {
                            moves.push(this.coordsToSquare(r, c));
                        } else {
                            if (this.isWhite(target) !== isWhitePiece && target.toLowerCase() !== 'k') {
                                moves.push(this.coordsToSquare(r, c));
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                return moves;
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            isSquareAttacked(square, byWhite) {
                const {row, col} = this.squareToCoords(square);
                
                // –ü–µ—à–∫–∏
                const pawnDirection = byWhite ? -1 : 1;
                for (let dc of [-1, 1]) {
                    const r = row + pawnDirection;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'p' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                // –ö–æ–Ω—å
                const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                for (const [dr, dc] of knightMoves) {
                    const r = row + dr;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'n' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                // –õ–∞–¥—å—è –∏ —Ñ–µ—Ä–∑—å
                const straight = [[1,0],[-1,0],[0,1],[0,-1]];
                for (const [dr, dc] of straight) {
                    let r = row + dr;
                    let c = col + dc;
                    while (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece) {
                            if ((piece.toLowerCase() === 'r' || piece.toLowerCase() === 'q') && 
                                this.isWhite(piece) === byWhite) {
                                return true;
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                // –°–ª–æ–Ω –∏ —Ñ–µ—Ä–∑—å
                const diagonal = [[1,1],[1,-1],[-1,1],[-1,-1]];
                for (const [dr, dc] of diagonal) {
                    let r = row + dr;
                    let c = col + dc;
                    while (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece) {
                            if ((piece.toLowerCase() === 'b' || piece.toLowerCase() === 'q') && 
                                this.isWhite(piece) === byWhite) {
                                return true;
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
                
                // –ö–æ—Ä–æ–ª—å
                const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
                for (const [dr, dc] of kingMoves) {
                    const r = row + dr;
                    const c = col + dc;
                    if (this.isValidSquare(r, c)) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'k' && this.isWhite(piece) === byWhite) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            isKingInCheck(color) {
                let kingSquare = null;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.toLowerCase() === 'k') {
                            const pieceColor = this.isWhite(piece) ? 'w' : 'b';
                            if (pieceColor === color) {
                                kingSquare = this.coordsToSquare(row, col);
                                break;
                            }
                        }
                    }
                    if (kingSquare) break;
                }
                
                if (!kingSquare) return false;
                
                const attackerColor = color === 'w' ? 'b' : 'w';
                return this.isSquareAttacked(kingSquare, attackerColor === 'w');
            }
            
            isCheckmate(color) {
                if (!this.isKingInCheck(color)) {
                    return false;
                }
                
                const moves = this.getAllLegalMoves(color);
                return moves.length === 0;
            }
            
            isStalemate(color) {
                if (this.isKingInCheck(color)) {
                    return false;
                }
                
                const moves = this.getAllLegalMoves(color);
                return moves.length === 0;
            }
            
            getAllLegalMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && ((color === 'w' && this.isWhite(piece)) || (color === 'b' && !this.isWhite(piece)))) {
                            const fromSquare = this.coordsToSquare(row, col);
                            const pieceMoves = this.getMovesForPiece(fromSquare);
                            
                            for (const to of pieceMoves) {
                                if (this.isMoveLegal(fromSquare, to)) {
                                    moves.push({from: fromSquare, to});
                                }
                            }
                        }
                    }
                }
                return moves;
            }
            
            isMoveLegal(from, to) {
                const testBoard = new ChessEngine();
                testBoard.board = JSON.parse(JSON.stringify(this.board));
                testBoard.castlingRights = JSON.parse(JSON.stringify(this.castlingRights));
                
                const fromCoords = this.squareToCoords(from);
                const toCoords = this.squareToCoords(to);
                const piece = testBoard.board[fromCoords.row][fromCoords.col];
                
                if (!piece) return false;
                
                const isWhitePiece = this.isWhite(piece);
                const pieceColor = isWhitePiece ? 'w' : 'b';
                
                const targetPiece = testBoard.board[toCoords.row][toCoords.col];
                if (targetPiece && targetPiece.toLowerCase() === 'k') {
                    return true;
                }
                
                // –†–û–ö–ò–†–û–í–ö–ê - –ø—Ä–æ–≤–µ—Ä–∫–∞
                if (piece.toLowerCase() === 'k') {
                    const colDiff = toCoords.col - fromCoords.col;
                    if (Math.abs(colDiff) === 2) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ—Ä–æ–ª—å –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ –∞—Ç–∞–∫–æ–≤–∞–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏
                        const step = colDiff > 0 ? 1 : -1;
                        for (let c = fromCoords.col; c !== toCoords.col; c += step) {
                            const square = this.coordsToSquare(fromCoords.row, c);
                            if (this.isSquareAttacked(square, !isWhitePiece)) {
                                return false;
                            }
                        }
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–ª–µ–≤—É—é –∫–ª–µ—Ç–∫—É
                        if (this.isSquareAttacked(to, !isWhitePiece)) {
                            return false;
                        }
                    }
                }
                
                // –î–µ–ª–∞–µ–º —Ö–æ–¥ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –¥–æ—Å–∫–µ
                testBoard.board[toCoords.row][toCoords.col] = piece;
                testBoard.board[fromCoords.row][fromCoords.col] = '';
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–π –¥–æ—Å–∫–∏
                if (piece.toLowerCase() === 'k') {
                    testBoard.castlingRights[isWhitePiece ? 'white' : 'black'].king = false;
                } else if (piece.toLowerCase() === 'r') {
                    const color = isWhitePiece ? 'white' : 'black';
                    if (fromCoords.row === (isWhitePiece ? 7 : 0)) {
                        if (fromCoords.col === 0) {
                            testBoard.castlingRights[color].queenside = false;
                        } else if (fromCoords.col === 7) {
                            testBoard.castlingRights[color].kingside = false;
                        }
                    }
                }
                
                return !testBoard.isKingInCheck(pieceColor);
            }
            
            move(from, to, promotionPiece = 'Q') {
                if (this.gameOver) {
                    console.log("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞, —Ö–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω");
                    return null;
                }
                
                const fromCoords = this.squareToCoords(from);
                const toCoords = this.squareToCoords(to);
                
                const piece = this.board[fromCoords.row][fromCoords.col];
                if (!piece) {
                    console.log("–ù–µ—Ç —Ñ–∏–≥—É—Ä—ã –Ω–∞ –∫–ª–µ—Ç–∫–µ", from);
                    return null;
                }
                
                const pieceColor = this.isWhite(piece) ? 'w' : 'b';
                if (this.turn !== pieceColor) {
                    console.log("–ù–µ –≤–∞—à —Ö–æ–¥. –û–∂–∏–¥–∞–µ—Ç—Å—è:", this.turn, "–∞ —Ñ–∏–≥—É—Ä–∞:", pieceColor);
                    return null;
                }
                
                if (!this.isMoveLegal(from, to)) {
                    console.log("–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ö–æ–¥:", from, "->", to);
                    return null;
                }
                
                const targetPiece = this.board[toCoords.row][toCoords.col];
                
                // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                if (piece.toLowerCase() === 'k' && Math.abs(toCoords.col - fromCoords.col) === 2) {
                    return this.performCastling(from, to);
                }
                
                const moveInfo = {
                    from: from,
                    to: to,
                    piece: piece,
                    captured: targetPiece,
                    check: false,
                    mate: false,
                    stalemate: false,
                    castle: false,
                    promotion: false
                };
                
                // –ü–†–ï–í–†–ê–©–ï–ù–ò–ï –ü–ï–®–ö–ò
                const isPawn = piece.toLowerCase() === 'p';
                const isPromotion = isPawn && (toCoords.row === 0 || toCoords.row === 7);
                
                if (isPromotion) {
                    const promotedPiece = this.isWhite(piece) ? promotionPiece : promotionPiece.toLowerCase();
                    this.board[toCoords.row][toCoords.col] = promotedPiece;
                    moveInfo.promotion = true;
                    moveInfo.promotedTo = promotedPiece;
                } else {
                    this.board[toCoords.row][toCoords.col] = piece;
                }
                
                this.board[fromCoords.row][fromCoords.col] = '';
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                if (piece.toLowerCase() === 'k') {
                    this.castlingRights[pieceColor === 'w' ? 'white' : 'black'].king = false;
                } else if (piece.toLowerCase() === 'r') {
                    const color = pieceColor === 'w' ? 'white' : 'black';
                    if (fromCoords.row === (pieceColor === 'w' ? 7 : 0)) {
                        if (fromCoords.col === 0) {
                            this.castlingRights[color].queenside = false;
                        } else if (fromCoords.col === 7) {
                            this.castlingRights[color].kingside = false;
                        }
                    }
                }
                
                // –ï—Å–ª–∏ –≤–∑—è—Ç–∞ –ª–∞–¥—å—è –Ω–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                if (targetPiece && targetPiece.toLowerCase() === 'r') {
                    const targetColor = this.isWhite(targetPiece) ? 'w' : 'b';
                    const color = targetColor === 'w' ? 'white' : 'black';
                    if (toCoords.row === (targetColor === 'w' ? 7 : 0)) {
                        if (toCoords.col === 0) {
                            this.castlingRights[color].queenside = false;
                        } else if (toCoords.col === 7) {
                            this.castlingRights[color].kingside = false;
                        }
                    }
                }
                
                this.turn = this.turn === 'w' ? 'b' : 'w';
                this.history.push(moveInfo);
                
                this.check.white = this.isKingInCheck('w');
                this.check.black = this.isKingInCheck('b');
                
                this.mate.white = this.isCheckmate('w');
                this.mate.black = this.isCheckmate('b');
                this.stalemate = this.isStalemate(this.turn);
                
                if (this.mate.white || this.mate.black) {
                    this.gameOver = true;
                    this.winner = this.mate.white ? 'black' : 'white';
                    moveInfo.mate = true;
                    console.log("–®–ê–• –ò –ú–ê–¢! –ü–æ–±–µ–¥–∏–ª–∏", this.winner);
                } else if (this.stalemate) {
                    this.gameOver = true;
                    this.winner = null;
                    moveInfo.stalemate = true;
                    console.log("–ü–ê–¢! –ù–∏—á—å—è!");
                }
                
                return moveInfo;
            }
            
            performCastling(from, to) {
                const fromCoords = this.squareToCoords(from);
                const toCoords = this.squareToCoords(to);
                const piece = this.board[fromCoords.row][fromCoords.col];
                const isWhite = this.isWhite(piece);
                
                const moveInfo = {
                    from: from,
                    to: to,
                    piece: piece,
                    captured: null,
                    check: false,
                    mate: false,
                    castle: true,
                    kingside: toCoords.col > fromCoords.col
                };
                
                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–æ—Ä–æ–ª—è
                this.board[toCoords.row][toCoords.col] = piece;
                this.board[fromCoords.row][fromCoords.col] = '';
                
                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –ª–∞–¥—å—é
                if (toCoords.col > fromCoords.col) {
                    // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (kingside)
                    const rookFromCol = 7;
                    const rookToCol = toCoords.col - 1;
                    const rook = this.board[fromCoords.row][rookFromCol];
                    this.board[fromCoords.row][rookToCol] = rook;
                    this.board[fromCoords.row][rookFromCol] = '';
                } else {
                    // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (queenside)
                    const rookFromCol = 0;
                    const rookToCol = toCoords.col + 1;
                    const rook = this.board[fromCoords.row][rookFromCol];
                    this.board[fromCoords.row][rookToCol] = rook;
                    this.board[fromCoords.row][rookFromCol] = '';
                }
                
                // –£–±–∏—Ä–∞–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                const color = isWhite ? 'white' : 'black';
                this.castlingRights[color].king = false;
                this.castlingRights[color].queenside = false;
                this.castlingRights[color].kingside = false;
                
                this.turn = this.turn === 'w' ? 'b' : 'w';
                this.history.push(moveInfo);
                
                this.check.white = this.isKingInCheck('w');
                this.check.black = this.isKingInCheck('b');
                
                return moveInfo;
            }
            
            undo() {
                if (this.history.length === 0) return null;
                
                const lastMove = this.history.pop();
                const fromCoords = this.squareToCoords(lastMove.from);
                const toCoords = this.squareToCoords(lastMove.to);
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏–≥—É—Ä—É
                this.board[fromCoords.row][fromCoords.col] = lastMove.piece;
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
                if (lastMove.castle) {
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ—Ä–æ–ª—è
                    this.board[toCoords.row][toCoords.col] = '';
                    
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ª–∞–¥—å—é
                    const isWhite = this.isWhite(lastMove.piece);
                    const row = isWhite ? 7 : 0;
                    
                    if (lastMove.kingside) {
                        // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                        this.board[row][7] = isWhite ? 'R' : 'r';
                        this.board[row][5] = '';
                    } else {
                        // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                        this.board[row][0] = isWhite ? 'R' : 'r';
                        this.board[row][3] = '';
                    }
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                    const color = isWhite ? 'white' : 'black';
                    this.castlingRights[color].king = true;
                    this.castlingRights[color].queenside = true;
                    this.castlingRights[color].kingside = true;
                } else {
                    // –û–±—ã—á–Ω—ã–π —Ö–æ–¥
                    if (lastMove.captured) {
                        this.board[toCoords.row][toCoords.col] = lastMove.captured;
                    } else {
                        this.board[toCoords.row][toCoords.col] = '';
                    }
                    
                    // –ï—Å–ª–∏ –±—ã–ª–∞ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—à–∫—É
                    if (lastMove.promotion) {
                        this.board[fromCoords.row][fromCoords.col] = this.isWhite(lastMove.piece) ? 'P' : 'p';
                    }
                }
                
                this.turn = this.turn === 'w' ? 'b' : 'w';
                
                this.gameOver = false;
                this.winner = null;
                this.check.white = this.isKingInCheck('w');
                this.check.black = this.isKingInCheck('b');
                this.mate.white = false;
                this.mate.black = false;
                this.stalemate = false;
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                if (lastMove.piece.toLowerCase() === 'k') {
                    const color = this.isWhite(lastMove.piece) ? 'white' : 'black';
                    this.castlingRights[color].king = true;
                }
                
                return lastMove;
            }
            
            findBestMoveForBot() {
                const moves = this.getAllLegalMoves('b');
                if (moves.length === 0) return null;
                
                let bestMove = null;
                let bestScore = -Infinity;
                
                if (this.check.black) {
                    console.log("–ë–æ—Ç –ø–æ–¥ —à–∞—Ö–æ–º! –ó–∞—â–∏—â–∞—é—Å—å...");
                    
                    for (const move of moves) {
                        let score = 0;
                        
                        const testBoard = new ChessEngine();
                        testBoard.board = JSON.parse(JSON.stringify(this.board));
                        testBoard.castlingRights = JSON.parse(JSON.stringify(this.castlingRights));
                        
                        const targetPiece = this.getPiece(move.to);
                        const movingPiece = this.getPiece(move.from);
                        
                        const moveResult = testBoard.move(move.from, move.to, 'q');
                        if (!moveResult) continue;
                        
                        if (!testBoard.isKingInCheck('b')) {
                            score += 1000;
                        } else {
                            continue;
                        }
                        
                        if (targetPiece) {
                            const pieceValues = {
                                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9
                            };
                            const value = pieceValues[targetPiece.toLowerCase()] || 0;
                            score += value * 10;
                        }
                        
                        // –ë–æ–Ω—É—Å –∑–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                        if (movingPiece.toLowerCase() === 'k' && Math.abs(move.to.charCodeAt(0) - move.from.charCodeAt(0)) === 2) {
                            score += 50;
                        }
                        
                        // –ë–æ–Ω—É—Å –∑–∞ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
                        if (movingPiece.toLowerCase() === 'p' && (move.to[1] === '1' || move.to[1] === '8')) {
                            score += 80;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                if (!bestMove) {
                    console.log("–ë–æ—Ç –∞—Ç–∞–∫—É–µ—Ç...");
                    
                    for (const move of moves) {
                        let score = 0;
                        
                        const targetPiece = this.getPiece(move.to);
                        const movingPiece = this.getPiece(move.from);
                        
                        if (targetPiece) {
                            const pieceValues = {
                                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9
                            };
                            const value = pieceValues[targetPiece.toLowerCase()] || 0;
                            score += value * 10;
                            
                            if (targetPiece.toLowerCase() === 'q') {
                                score += 500;
                            }
                        }
                        
                        const testBoard = new ChessEngine();
                        testBoard.board = JSON.parse(JSON.stringify(this.board));
                        testBoard.castlingRights = JSON.parse(JSON.stringify(this.castlingRights));
                        const moveResult = testBoard.move(move.from, move.to, 'q');
                        
                        if (moveResult && moveResult.check) {
                            score += 100;
                        }
                        
                        // –ë–æ–Ω—É—Å –∑–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                        if (movingPiece.toLowerCase() === 'k' && Math.abs(move.to.charCodeAt(0) - move.from.charCodeAt(0)) === 2) {
                            score += 50;
                        }
                        
                        // –ë–æ–Ω—É—Å –∑–∞ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
                        if (movingPiece.toLowerCase() === 'p' && (move.to[1] === '1' || move.to[1] === '8')) {
                            score += 80;
                        }
                        
                        // –ö–æ–Ω—Ç—Ä–æ–ª—å —Ü–µ–Ω—Ç—Ä–∞
                        const centerSquares = ['d4', 'd5', 'e4', 'e5'];
                        if (centerSquares.includes(move.to)) {
                            score += 3;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                return bestMove || moves[0];
            }
        }
        
        // ============= –ò–ù–¢–ï–†–§–ï–ô–° –ò –ò–ì–†–ê =============
        const chess = new ChessEngine();
        let selectedSquare = null;
        let possibleMoves = [];
        let boardFlipped = false;
        let gameStartTime = Date.now();
        let moveCount = 1;
        let soundEnabled = true;
        let pendingPromotion = null;
        
        // ============= –¢–ê–ô–ú–ï–† (1 –ú–ò–ù–£–¢–ê) =============
        let whiteTime = 60; // 1 –º–∏–Ω—É—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        let blackTime = 60; // 1 –º–∏–Ω—É—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        let timerInterval = null;
        let isTimerRunning = false;
        let lastMoveTime = Date.now();
        
        const pieceSymbols = {
            'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'p': '‚ôü',
            'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'P': '‚ôô'
        };
        
        function playSound(type) {
            if (!soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'move':
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    case 'capture':
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'check':
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'mate':
                        oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.5);
                        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.8);
                        break;
                    case 'castle':
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                    case 'draw':
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(165, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime + 0.2);
                        oscillator.frequency.setValueAtTime(165, audioContext.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                }
            } catch (e) {
                console.log("–ê—É–¥–∏–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞
        function updateTimer() {
            if (!isTimerRunning || chess.gameOver) return;
            
            const now = Date.now();
            const elapsed = Math.floor((now - lastMoveTime) / 1000);
            
            if (elapsed > 0) {
                // –¢–∞–π–º–µ—Ä –≤—Å–µ–≥–¥–∞ –æ—Ç—Å—á–∏—Ç—ã–≤–∞–µ—Ç –≤—Ä–µ–º—è —É —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
                if (chess.turn === 'w') {
                    whiteTime = Math.max(0, whiteTime - elapsed);
                    if (whiteTime <= 0) {
                        whiteTime = 0;
                        handleTimeout('white');
                        return;
                    }
                } else {
                    blackTime = Math.max(0, blackTime - elapsed);
                    if (blackTime <= 0) {
                        blackTime = 0;
                        handleTimeout('black');
                        return;
                    }
                }
                lastMoveTime = now;
                updateTimerDisplay();
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞
        function updateTimerDisplay() {
            const whiteMinutes = Math.floor(whiteTime / 60);
            const whiteSeconds = whiteTime % 60;
            const blackMinutes = Math.floor(blackTime / 60);
            const blackSeconds = blackTime % 60;
            
            const whiteTimer = document.getElementById('whiteTimer');
            const blackTimer = document.getElementById('blackTimer');
            
            whiteTimer.textContent = `${whiteMinutes.toString().padStart(2, '0')}:${whiteSeconds.toString().padStart(2, '0')}`;
            blackTimer.textContent = `${blackMinutes.toString().padStart(2, '0')}:${blackSeconds.toString().padStart(2, '0')}`;
            
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –Ω–∏–∑–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (–º–µ–Ω–µ–µ 10 —Å–µ–∫—É–Ω–¥)
            whiteTimer.classList.toggle('timer-low', whiteTime < 10 && whiteTime > 0);
            blackTimer.classList.toggle('timer-low', blackTime < 10 && blackTime > 0);
            
            // –£—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏ < 10 —Å–µ–∫—É–Ω–¥
            if (whiteTime < 10 && whiteTime > 0) {
                whiteTimer.style.animation = 'timerPulse 0.3s infinite';
            } else {
                whiteTimer.style.animation = '';
            }
            
            if (blackTime < 10 && blackTime > 0) {
                blackTimer.style.animation = 'timerPulse 0.3s infinite';
            } else {
                blackTimer.style.animation = '';
            }
        }
        
        // –ó–∞–ø—É—Å–∫/–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–∞–π–º–µ—Ä–∞
        function toggleTimer(forceStart = false) {
            if (chess.gameOver) {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                isTimerRunning = false;
                return;
            }
            
            if (forceStart || !isTimerRunning) {
                isTimerRunning = true;
                lastMoveTime = Date.now();
                
                if (!timerInterval) {
                    timerInterval = setInterval(updateTimer, 100);
                }
            } else {
                isTimerRunning = false;
                updateTimer(); // –û–±–Ω–æ–≤–ª—è–µ–º –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
        function handleTimeout(color) {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            chess.gameOver = true;
            chess.winner = color === 'white' ? 'black' : 'white';
            
            playSound('mate');
            showMessage(`‚è∞ –í—Ä–µ–º—è –≤—ã—à–ª–æ! –ü–æ–±–µ–¥–∏–ª–∏ ${chess.winner === 'white' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'}!`);
            updateStatus();
            updateBoard();
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ö–æ–¥–∞
        function switchTimer() {
            if (!isTimerRunning) return;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –¥–ª—è –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
            updateTimer();
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º lastMoveTime –¥–ª—è –Ω–æ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            lastMoveTime = Date.now();
            
            updateTimerDisplay();
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ç–∞ –∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞
        function checkForStalemate() {
            if (chess.gameOver) return false;
            
            const currentPlayer = chess.turn;
            const opponentColor = currentPlayer === 'w' ? 'b' : 'w';
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç
            if (!chess.isKingInCheck(currentPlayer)) {
                const legalMoves = chess.getAllLegalMoves(currentPlayer);
                
                if (legalMoves.length === 0) {
                    // –ü–∞—Ç!
                    chess.gameOver = true;
                    chess.winner = null;
                    chess.stalemate = true;
                    
                    playSound('draw');
                    showMessage("ü§ù –ü–∞—Ç! –ù–∏—á—å—è!");
                    updateStatus();
                    updateBoard();
                    
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    
                    return true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –º–∞—Ç–∞
            if (isInsufficientMaterial()) {
                chess.gameOver = true;
                chess.winner = null;
                
                playSound('draw');
                showMessage("ü§ù –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –¥–ª—è –º–∞—Ç–∞! –ù–∏—á—å—è!");
                updateStatus();
                updateBoard();
                
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                return true;
            }
            
            return false;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –º–∞—Ç–∞
        function isInsufficientMaterial() {
            let whitePieces = [];
            let blackPieces = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chess.board[row][col];
                    if (piece) {
                        if (chess.isWhite(piece)) {
                            whitePieces.push(piece.toLowerCase());
                        } else {
                            blackPieces.push(piece.toLowerCase());
                        }
                    }
                }
            }
            
            // –¢–æ–ª—å–∫–æ –∫–æ—Ä–æ–ª–∏
            if (whitePieces.length === 1 && blackPieces.length === 1) {
                return true;
            }
            
            // –ö–æ—Ä–æ–ª—å + —Å–ª–æ–Ω –ø—Ä–æ—Ç–∏–≤ –∫–æ—Ä–æ–ª—è
            const whiteOnlyKingAndBishop = whitePieces.length === 2 && whitePieces.includes('b');
            const blackOnlyKingAndBishop = blackPieces.length === 2 && blackPieces.includes('b');
            
            if ((whitePieces.length === 1 && blackOnlyKingAndBishop) ||
                (blackPieces.length === 1 && whiteOnlyKingAndBishop)) {
                return true;
            }
            
            // –ö–æ—Ä–æ–ª—å + –∫–æ–Ω—å –ø—Ä–æ—Ç–∏–≤ –∫–æ—Ä–æ–ª—è
            const whiteOnlyKingAndKnight = whitePieces.length === 2 && whitePieces.includes('n');
            const blackOnlyKingAndKnight = blackPieces.length === 2 && blackPieces.includes('n');
            
            if ((whitePieces.length === 1 && blackOnlyKingAndKnight) ||
                (blackPieces.length === 1 && whiteOnlyKingAndKnight)) {
                return true;
            }
            
            return false;
        }
        
        function initBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    
                    const file = String.fromCharCode(97 + col);
                    const rank = 8 - row;
                    const squareName = file + rank;
                    square.dataset.square = squareName;
                    
                    const isLight = (row + col) % 2 === 0;
                    square.classList.add(isLight ? 'light' : 'dark');
                    
                    square.addEventListener('click', () => handleSquareClick(squareName));
                    board.appendChild(square);
                }
            }
            
            updateBoard();
            updateStatus();
            updatePieceCount();
            updateTimerDisplay();
            toggleTimer(true); // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä —Å—Ä–∞–∑—É
        }
        
        function updateBoard() {
            document.querySelectorAll('.square').forEach(sq => {
                const oldPiece = sq.querySelector('.piece');
                if (oldPiece) oldPiece.remove();
                
                sq.classList.remove('selected', 'possible-move', 'capture-move', 
                                   'check', 'mate', 'king-attack', 'castle-move');
            });
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chess.board[row][col];
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                    
                    if (square && piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.textContent = pieceSymbols[piece];
                        pieceEl.className = `piece ${chess.isWhite(piece) ? 'white' : 'black'}`;
                        
                        if (selectedSquare === `${String.fromCharCode(97 + col)}${8 - row}`) {
                            pieceEl.classList.add('selected-piece');
                        }
                        
                        square.appendChild(pieceEl);
                    }
                }
            }
            
            if (chess.check.white) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === 'K') {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('check');
                        }
                    }
                }
            }
            
            if (chess.check.black) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === 'k') {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('check');
                        }
                    }
                }
            }
            
            if (chess.mate.white || chess.mate.black) {
                const color = chess.mate.white ? 'white' : 'black';
                const kingSymbol = color === 'white' ? 'K' : 'k';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (chess.board[row][col] === kingSymbol) {
                            const square = document.querySelector(`[data-square="${String.fromCharCode(97 + col)}${8 - row}"]`);
                            if (square) square.classList.add('mate');
                        }
                    }
                }
            }
            
            if (selectedSquare) {
                const squareEl = document.querySelector(`[data-square="${selectedSquare}"]`);
                if (squareEl) squareEl.classList.add('selected');
                
                // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ —Å —É—á–µ—Ç–æ–º —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
                possibleMoves.forEach(move => {
                    const squareEl = document.querySelector(`[data-square="${move}"]`);
                    if (squareEl) {
                        const targetPiece = chess.getPiece(move);
                        if (targetPiece) {
                            if (targetPiece.toLowerCase() === 'k') {
                                squareEl.classList.add('king-attack');
                            } else {
                                squareEl.classList.add('capture-move');
                            }
                        } else {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ —Ä–æ–∫–∏—Ä–æ–≤–∫–æ–π
                            const selectedPiece = chess.getPiece(selectedSquare);
                            if (selectedPiece && selectedPiece.toLowerCase() === 'k') {
                                const fromCol = selectedSquare.charCodeAt(0) - 97;
                                const toCol = move.charCodeAt(0) - 97;
                                if (Math.abs(toCol - fromCol) === 2) {
                                    squareEl.classList.add('castle-move');
                                } else {
                                    squareEl.classList.add('possible-move');
                                }
                            } else {
                                squareEl.classList.add('possible-move');
                            }
                        }
                    }
                });
            }
            
            if (boardFlipped) {
                document.getElementById('board').style.transform = 'rotate(180deg)';
                document.querySelectorAll('.square').forEach(sq => {
                    sq.style.transform = 'rotate(180deg)';
                });
            } else {
                document.getElementById('board').style.transform = 'rotate(0deg)';
                document.querySelectorAll('.square').forEach(sq => {
                    sq.style.transform = 'rotate(0deg)';
                });
            }
            
            updateTurnIndicator();
            updateCastleStatus();
        }
        
        function handleSquareClick(square) {
            if (chess.gameOver) {
                showMessage(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! ${chess.winner ? `–ü–æ–±–µ–¥–∏–ª–∏ ${chess.winner === 'white' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'}!` : '–ù–∏—á—å—è!'}`);
                return;
            }
            
            if (chess.turn === 'b' && document.getElementById('botThinking').style.display !== 'none') {
                return;
            }
            
            if (possibleMoves.includes(square)) {
                const piece = chess.getPiece(selectedSquare);
                const isPawn = piece && piece.toLowerCase() === 'p';
                const toRow = 8 - parseInt(square[1]);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
                if (isPawn && (toRow === 0 || toRow === 7)) {
                    pendingPromotion = { from: selectedSquare, to: square };
                    showPromotionModal(chess.isWhite(piece));
                    return;
                }
                
                makeMove(selectedSquare, square);
                return;
            }
            
            const piece = chess.getPiece(square);
            if (!piece) {
                selectedSquare = null;
                possibleMoves = [];
                updateBoard();
                return;
            }
            
            const pieceColor = chess.isWhite(piece) ? 'w' : 'b';
            if (chess.turn !== pieceColor) {
                showMessage("–ù–µ –≤–∞—à —Ö–æ–¥! –°–µ–π—á–∞—Å —Ö–æ–¥—è—Ç " + (chess.turn === 'w' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'));
                return;
            }
            
            selectedSquare = square;
            possibleMoves = chess.getMovesForPiece(square);
            possibleMoves = possibleMoves.filter(move => chess.isMoveLegal(square, move));
            
            updateBoard();
            
            if (possibleMoves.length > 0) {
                playSound('move');
            }
        }
        
        function makeMove(from, to, promotionPiece = 'Q') {
            console.log("–ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥:", from, "->", to);
            
            const move = chess.move(from, to, promotionPiece);
            if (!move) {
                console.log("–•–æ–¥ –Ω–µ —É–¥–∞–ª—Å—è");
                selectedSquare = null;
                possibleMoves = [];
                updateBoard();
                return;
            }
            
            console.log("–•–æ–¥ —É—Å–ø–µ—à–µ–Ω:", move);
            
            // –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
            if (move.castle) {
                playSound('castle');
            } else if (move.captured) {
                playSound('capture');
            } else if (move.check) {
                playSound('check');
            } else {
                playSound('move');
            }
            
            if (move.mate) {
                playSound('mate');
            } else if (move.stalemate) {
                playSound('draw');
            }
            
            selectedSquare = null;
            possibleMoves = [];
            
            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ç–∞–π–º–µ—Ä –ø—Ä–∏ —Å–º–µ–Ω–µ —Ö–æ–¥–∞
            switchTimer();
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ö–æ–¥ –≤ –∏—Å—Ç–æ—Ä–∏—é
            addMoveToHistory(move);
            moveCount++;
            
            updateBoard();
            updateStatus();
            updatePieceCount();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç –ø–æ—Å–ª–µ —Ö–æ–¥–∞ –∏–≥—Ä–æ–∫–∞
            setTimeout(() => {
                checkForStalemate();
            }, 100);
            
            // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –•–û–î –ë–û–¢–ê
            if (!chess.gameOver && chess.turn === 'b') {
                setTimeout(makeBotMove, 800);
            }
        }
        
        function makeBotMove() {
            console.log("=== –ë–û–¢ –î–ï–õ–ê–ï–¢ –•–û–î ===");
            
            const thinkingIndicator = document.getElementById('botThinking');
            thinkingIndicator.style.display = 'block';
            
            setTimeout(() => {
                if (chess.gameOver) {
                    thinkingIndicator.style.display = 'none';
                    console.log("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞");
                    return;
                }
                
                const bestMove = chess.findBestMoveForBot();
                
                if (bestMove) {
                    console.log("–ë–æ—Ç –≤—ã–±—Ä–∞–ª:", bestMove.from, "->", bestMove.to);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –±–æ—Ç–∞
                    const piece = chess.getPiece(bestMove.from);
                    const isPawn = piece && piece.toLowerCase() === 'p';
                    const toRow = 8 - parseInt(bestMove.to[1]);
                    
                    if (isPawn && (toRow === 0 || toRow === 7)) {
                        // –ë–æ—Ç –≤—Å–µ–≥–¥–∞ –≤—ã–±–∏—Ä–∞–µ—Ç —Ñ–µ—Ä–∑—è –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è
                        chess.move(bestMove.from, bestMove.to, 'q');
                    } else {
                        chess.move(bestMove.from, bestMove.to, 'q');
                    }
                    
                    playSound('move');
                    
                    // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ç–∞–π–º–µ—Ä –ø—Ä–∏ —Å–º–µ–Ω–µ —Ö–æ–¥–∞
                    switchTimer();
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º —Ö–æ–¥ –≤ –∏—Å—Ç–æ—Ä–∏—é
                    const moveInfo = chess.history[chess.history.length - 1];
                    addMoveToHistory(moveInfo, true);
                    
                    updateBoard();
                    updateStatus();
                    updatePieceCount();
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç –ø–æ—Å–ª–µ —Ö–æ–¥–∞ –±–æ—Ç–∞
                    setTimeout(() => {
                        checkForStalemate();
                    }, 100);
                } else {
                    console.log("–ë–æ—Ç –Ω–µ –Ω–∞—à–µ–ª —Ö–æ–¥");
                    checkForStalemate(); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç, –µ—Å–ª–∏ —É –±–æ—Ç–∞ –Ω–µ—Ç —Ö–æ–¥–æ–≤
                }
                
                thinkingIndicator.style.display = 'none';
                console.log("=== –•–û–î –ë–û–¢–ê –ó–ê–í–ï–†–®–ï–ù ===");
            }, 800);
        }
        
        function showPromotionModal(isWhite) {
            const modal = document.getElementById('promotionModal');
            const pieces = modal.querySelectorAll('.promotion-piece');
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç —Ñ–∏–≥—É—Ä
            pieces.forEach(piece => {
                piece.className = `promotion-piece ${isWhite ? 'white' : 'black'}`;
                const pieceSymbol = piece.getAttribute('data-piece');
                piece.textContent = pieceSymbols[isWhite ? pieceSymbol : pieceSymbol.toLowerCase()];
            });
            
            modal.style.display = 'flex';
        }
        
        function hidePromotionModal() {
            const modal = document.getElementById('promotionModal');
            modal.style.display = 'none';
        }
        
        function promotePawn(piece) {
            if (pendingPromotion) {
                makeMove(pendingPromotion.from, pendingPromotion.to, piece);
                pendingPromotion = null;
                hidePromotionModal();
            }
        }
        
        function updateStatus() {
            const status = document.getElementById('status');
            
            if (chess.gameOver) {
                if (chess.winner) {
                    status.classList.add('victory');
                    status.innerHTML = `üèÜ <strong>–®–ê–• –ò –ú–ê–¢!</strong> –ü–æ–±–µ–¥–∏–ª–∏ ${chess.winner === 'white' ? '–±–µ–ª—ã–µ' : '—á–µ—Ä–Ω—ã–µ'}!`;
                } else if (chess.stalemate) {
                    status.classList.add('draw');
                    status.innerHTML = 'ü§ù <strong>–ü–ê–¢!</strong> –ù–∏—á—å—è!';
                } else {
                    status.classList.add('draw');
                    status.innerHTML = 'ü§ù <strong>–ù–∏—á—å—è!</strong> –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –¥–ª—è –º–∞—Ç–∞.';
                }
                return;
            }
            
            status.classList.remove('victory', 'warning', 'draw');
            
            if (chess.turn === 'w') {
                status.innerHTML = '‚úÖ <strong>–í–∞—à —Ö–æ–¥</strong> (–±–µ–ª—ã–µ)';
                if (chess.check.white) {
                    status.classList.add('warning');
                    status.innerHTML = '‚ö†Ô∏è <strong>–®–ê–•!</strong> –í–∞—à –∫–æ—Ä–æ–ª—å –ø–æ–¥ –∞—Ç–∞–∫–æ–π!';
                }
            } else {
                status.innerHTML = 'ü§ñ <strong>–•–æ–¥ –±–æ—Ç–∞</strong> (—á–µ—Ä–Ω—ã–µ)...';
                if (chess.check.black) {
                    status.classList.add('warning');
                    status.innerHTML = '‚ö†Ô∏è <strong>–®–ê–•!</strong> –ë–æ—Ç –∑–∞—â–∏—â–∞–µ—Ç—Å—è...';
                }
            }
        }
        
        function updateTurnIndicator() {
            const whiteTurn = document.querySelector('.turn-white');
            const blackTurn = document.querySelector('.turn-black');
            
            if (chess.turn === 'w') {
                whiteTurn.classList.add('active');
                blackTurn.classList.remove('active');
            } else {
                blackTurn.classList.add('active');
                whiteTurn.classList.remove('active');
            }
        }
        
        function updatePieceCount() {
            let whiteCount = 0;
            let blackCount = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = chess.board[row][col];
                    if (piece) {
                        if (chess.isWhite(piece)) {
                            whiteCount++;
                        } else {
                            blackCount++;
                        }
                    }
                }
            }
            
            document.getElementById('whitePieces').textContent = `–ë–µ–ª—ã–µ: ${whiteCount}`;
            document.getElementById('blackPieces').textContent = `–ß–µ—Ä–Ω—ã–µ: ${blackCount}`;
        }
        
        function updateCastleStatus() {
            const status = document.getElementById('castleStatus');
            const whiteRights = chess.castlingRights.white;
            const blackRights = chess.castlingRights.black;
            
            let text = "–†–æ–∫–∏—Ä–æ–≤–∫–∞: ";
            let whiteText = "";
            let blackText = "";
            
            if (whiteRights.king) {
                if (whiteRights.kingside && whiteRights.queenside) {
                    whiteText = "–±–µ–ª—ã–µ - –æ–±–µ";
                } else if (whiteRights.kingside) {
                    whiteText = "–±–µ–ª—ã–µ - –∫–æ—Ä–æ—Ç–∫–∞—è";
                } else if (whiteRights.queenside) {
                    whiteText = "–±–µ–ª—ã–µ - –¥–ª–∏–Ω–Ω–∞—è";
                } else {
                    whiteText = "–±–µ–ª—ã–µ - –Ω–µ—Ç";
                }
            } else {
                whiteText = "–±–µ–ª—ã–µ - –Ω–µ—Ç";
            }
            
            if (blackRights.king) {
                if (blackRights.kingside && blackRights.queenside) {
                    blackText = "—á–µ—Ä–Ω—ã–µ - –æ–±–µ";
                } else if (blackRights.kingside) {
                    blackText = "—á–µ—Ä–Ω—ã–µ - –∫–æ—Ä–æ—Ç–∫–∞—è";
                } else if (blackRights.queenside) {
                    blackText = "—á–µ—Ä–Ω—ã–µ - –¥–ª–∏–Ω–Ω–∞—è";
                } else {
                    blackText = "—á–µ—Ä–Ω—ã–µ - –Ω–µ—Ç";
                }
            } else {
                blackText = "—á–µ—Ä–Ω—ã–µ - –Ω–µ—Ç";
            }
            
            status.textContent = `${text}${whiteText}, ${blackText}`;
        }
        
        function addMoveToHistory(move, isBlack = false) {
            const historyDiv = document.getElementById('moveHistory');
            
            let moveText = '';
            const piece = move.piece;
            const isWhitePiece = chess.isWhite(piece);
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–º–≤–æ–ª —Ñ–∏–≥—É—Ä—ã
            let pieceSymbol = '';
            if (piece.toLowerCase() !== 'p') {
                pieceSymbol = pieceSymbols[isWhitePiece ? piece.toUpperCase() : piece.toLowerCase()];
            }
            
            // –î–ª—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
            if (move.castle) {
                moveText = move.kingside ? 'O-O' : 'O-O-O';
            } else {
                moveText = `${pieceSymbol}${move.to}`;
                
                // –î–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è
                if (move.promotion) {
                    const promotedSymbol = pieceSymbols[move.promotedTo];
                    moveText = `${move.to}${promotedSymbol}`;
                }
            }
            
            // –î–ª—è –≤–∑—è—Ç–∏—è
            if (move.captured) {
                if (piece.toLowerCase() === 'p') {
                    moveText = `${move.from[0]}x${move.to}`;
                } else {
                    moveText = `${pieceSymbol}x${move.to}`;
                }
            }
            
            // –î–ª—è —à–∞—Ö–∞ –∏ –º–∞—Ç–∞
            if (move.mate) {
                moveText += '#';
            } else if (move.check) {
                moveText += '+';
            } else if (move.stalemate) {
                moveText += ' (=)';
            }
            
            if (isBlack) {
                const lastEntry = historyDiv.lastElementChild;
                if (lastEntry) {
                    const blackSpan = lastEntry.querySelector('.move-black');
                    if (blackSpan.textContent === '-') {
                        blackSpan.textContent = moveText;
                        if (move.castle) blackSpan.classList.add('move-castle');
                        if (move.promotion) blackSpan.classList.add('move-promotion');
                        if (move.check && !move.mate) blackSpan.classList.add('move-check');
                        if (move.mate) blackSpan.classList.add('move-mate');
                    } else {
                        createHistoryEntry();
                    }
                }
            } else {
                createHistoryEntry();
            }
            
            function createHistoryEntry() {
                const entry = document.createElement('div');
                entry.className = 'move-entry';
                
                const moveNumber = document.createElement('span');
                moveNumber.className = 'move-number';
                moveNumber.textContent = Math.floor((historyDiv.children.length + 2) / 2) + '.';
                
                const whiteMove = document.createElement('span');
                whiteMove.className = 'move-white';
                whiteMove.textContent = moveText;
                if (move.castle) whiteMove.classList.add('move-castle');
                if (move.promotion) whiteMove.classList.add('move-promotion');
                if (move.check && !move.mate) whiteMove.classList.add('move-check');
                if (move.mate) whiteMove.classList.add('move-mate');
                
                const blackMove = document.createElement('span');
                blackMove.className = 'move-black';
                blackMove.textContent = '-';
                
                entry.appendChild(moveNumber);
                entry.appendChild(whiteMove);
                entry.appendChild(blackMove);
                historyDiv.appendChild(entry);
                
                historyDiv.scrollTop = historyDiv.scrollHeight;
            }
        }
        
        function showMessage(text) {
            const status = document.getElementById('status');
            const original = status.innerHTML;
            
            status.innerHTML = `üí¨ ${text}`;
            status.style.background = 'linear-gradient(135deg, rgba(255, 193, 7, 0.7), rgba(255, 152, 0, 0.7))';
            
            setTimeout(() => {
                status.innerHTML = original;
                status.style.background = '';
                updateStatus();
            }, 2000);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.getElementById('newGameBtn').addEventListener('click', () => {
            chess.reset();
            selectedSquare = null;
            possibleMoves = [];
            moveCount = 1;
            gameStartTime = Date.now();
            whiteTime = 60; // 1 –º–∏–Ω—É—Ç–∞
            blackTime = 60; // 1 –º–∏–Ω—É—Ç–∞
            pendingPromotion = null;
            hidePromotionModal();
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ç–∞–π–º–µ—Ä
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            isTimerRunning = false;
            
            document.getElementById('moveHistory').innerHTML = 
                '<div class="move-entry"><span class="move-number">1.</span> <span class="move-white">-</span> <span class="move-black">-</span></div>';
            
            updateBoard();
            updateStatus();
            updatePieceCount();
            updateTimerDisplay();
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
            toggleTimer(true);
            
            showMessage("–ù–æ–≤–∞—è –∏–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞! –£ –∫–∞–∂–¥–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø–æ 1 –º–∏–Ω—É—Ç–µ.");
        });
        
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (chess.history.length >= 2) {
                // –û—Ç–º–µ–Ω—è–µ–º –¥–≤–∞ —Ö–æ–¥–∞ (–∏–≥—Ä–æ–∫–∞ –∏ –±–æ—Ç–∞)
                chess.undo(); // —Ö–æ–¥ –±–æ—Ç–∞
                chess.undo(); // —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞
                moveCount -= 2;
                pendingPromotion = null;
                hidePromotionModal();
                
                const historyDiv = document.getElementById('moveHistory');
                if (historyDiv.children.length > 1) {
                    historyDiv.removeChild(historyDiv.lastElementChild);
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–µ—Ä—ã –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Ä–µ–º—è –¥–ª—è –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
                whiteTime = Math.min(whiteTime + 5, 60); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º 5 —Å–µ–∫—É–Ω–¥
                blackTime = Math.min(blackTime + 5, 60); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º 5 —Å–µ–∫—É–Ω–¥
                updateTimerDisplay();
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
                lastMoveTime = Date.now();
                
                playSound('move');
            } else if (chess.history.length === 1) {
                // –û—Ç–º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞ (–µ—Å–ª–∏ –±–æ—Ç –µ—â–µ –Ω–µ —Ö–æ–¥–∏–ª)
                chess.undo();
                moveCount -= 1;
                pendingPromotion = null;
                hidePromotionModal();
                
                whiteTime = Math.min(whiteTime + 5, 60);
                updateTimerDisplay();
                lastMoveTime = Date.now();
                
                playSound('move');
            } else {
                showMessage("–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å");
            }
            selectedSquare = null;
            possibleMoves = [];
            updateBoard();
            updateStatus();
            updatePieceCount();
        });
        
        document.getElementById('hintBtn').addEventListener('click', () => {
            if (chess.turn === 'w' && !chess.gameOver) {
                const moves = chess.getAllLegalMoves('w');
                if (moves.length > 0) {
                    const randomMove = moves[Math.floor(Math.random() * moves.length)];
                    selectedSquare = randomMove.from;
                    possibleMoves = [randomMove.to];
                    updateBoard();
                    
                    showMessage(`–ü–æ–¥—Å–∫–∞–∑–∫–∞: ${randomMove.from} ‚Üí ${randomMove.to}`);
                }
            } else {
                showMessage("–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∫–∞ –±—É–¥–µ—Ç –≤–∞—à —Ö–æ–¥!");
            }
        });
        
        document.getElementById('flipBtn').addEventListener('click', () => {
            boardFlipped = !boardFlipped;
            updateBoard();
            showMessage(`–î–æ—Å–∫–∞ ${boardFlipped ? '–ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç–∞' : '–≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º –ø–æ–ª–æ–∂–µ–Ω–∏–∏'}`);
        });
        
        document.getElementById('soundToggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            const toggle = document.getElementById('soundToggle');
            toggle.textContent = soundEnabled ? 'üîä' : 'üîá';
            toggle.style.background = soundEnabled ? 
                'rgba(40, 45, 55, 0.9)' : 'rgba(255, 100, 100, 0.3)';
            
            showMessage(`–ó–≤—É–∫ ${soundEnabled ? '–≤–∫–ª—é—á–µ–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`);
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—à–∫–∏
        document.querySelectorAll('.promotion-piece').forEach(piece => {
            piece.addEventListener('click', () => {
                const pieceType = piece.getAttribute('data-piece');
                promotePawn(pieceType);
            });
        });
        
        window.addEventListener('DOMContentLoaded', () => {
            initBoard();
            setTimeout(() => {
                showMessage("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –¢–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω—ã —Ä–æ–∫–∏—Ä–æ–≤–∫–∞, –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –∏ —Ç–∞–π–º–µ—Ä –Ω–∞ 1 –º–∏–Ω—É—Ç—É!");
            }, 1000);
        });
    </script>
</body>
</html>